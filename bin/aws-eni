#!/usr/bin/env ruby
require 'gli'
require 'resolv'
require 'ipaddr'
require 'aws-eni'

include GLI::App

program_desc 'Manage and sync local network config with AWS Elastic Network Interfaces'

@version = Aws::ENI::VERSION

autocomplete_commands true
subcommand_option_handling :normal
arguments :loose
sort_help :manually

# global options

desc 'Display the program version'
switch [:v,:version], negatable: false

desc 'Display all system commands and warnings'
switch [:V,:verbose], negatable: false

pre do |opt|
  Aws::ENI::IFconfig.verbose = opt[:verbose]
  true
end

# arg parser methods

def local_ip?(ip)
  IPAddr.new(Aws::ENI.environment[:vpc_cidr]) === IPAddr.new(ip)
end

def parse_args(args, *accept)
  params = {}
  args.each do |arg|
    if arg =~ /^eth[0-9]+/ && accept.include?(:device_name)
      help_now! "You may only specify one device name." if params[:device_name]
      params[:device_name] = arg
    elsif arg =~ /^eni-/ && accept.include?(:interface_id)
      help_now! "You may only specify one interface ID." if params[:interface_id]
      params[:interface_id] = arg
    elsif arg =~ /^subnet-/ && accept.include?(:subnet_id)
      help_now! "You may only specify one subnet." if params[:subnet_id]
      params[:subnet_id] = arg
    elsif arg =~ /^sg-/ && accept.include?(:security_groups)
      params[:security_groups] ||= []
      params[:security_groups] << arg
    elsif arg =~ /^eipalloc-/ && accept.include?(:allocation_id)
      help_now! "You may only specify one allocation ID" if params[:allocation_id]
      params[:allocation_id] = arg
    elsif arg =~ /^eipassoc-/ && accept.include?(:association_id)
      help_now! "You may only specify one association ID" if params[:association_id]
      params[:association_id] = arg
    elsif arg =~ Resolv::IPv4::Regex
      if local_ip? arg
        if accept.include?(:primary_ip)
          help_now! "You may only specify one primary IP address." if params[:primary_ip]
          params[:primary_ip] = arg
        elsif accept.include?(:private_ip)
          help_now! "You may only specify one private IP address." if params[:private_ip]
          params[:private_ip] = arg
        else
          help_now! "Invalid IP address: #{arg}"
        end
      elsif accept.include?(:public_ip)
        help_now! "You may only specify one public IP address." if params[:public_ip]
        params[:public_ip] = arg
      else
        help_now! "Invalid IP address: #{arg}"
      end
    else
      help_now! "Invalid argument: #{arg}"
    end
  end
  params
end

# commands

desc 'List current interface configuration'
long_desc %{
  List information about a set of interfaces including interface ID, interface
  name, MAC address, and a list of primary and secondary IP addresses along with
  any public ips associated with them.

  Use the optional filter argument to limit the listing to interfaces with a
  matching name, interface ID, subnet ID, or MAC address (default 'all').
}
arg 'filter', :optional
command [:list,:ls] do |c|
  c.action do |global,opts,args|
    help_now! "Too many arguments" if args.count > 1
    args.delete('all')
    Aws::ENI.list(args.first).each do |interface|
      print "#{interface[:name]}:"
      print "\tID #{interface[:interface_id]}"
      print "  HWaddr #{interface[:hwaddr]}"
      print "  Status " << (interface[:enabled] ? "UP" : "DOWN") << "\n"
      interface[:local_ips].each do |local_ip|
        if interface[:public_ips][local_ip]
          puts "\t#{local_ip} => #{interface[:public_ips][local_ip]}"
        else
          puts "\t#{local_ip}"
        end
      end
    end
    puts "\ninterface config is out of sync" if Aws::ENI.configure(nil, dry_run: true) > 0
  end
end

desc 'Configure network interfaces'
long_desc %{
  Syncronize configuration for a set of interfaces to match their configuration
  on AWS by managing secondary ips, routes, and rules.

  Use the optional filter argument to limit this action to interfaces with a
  matching name, interface ID, subnet ID, or MAC address (default 'all').
}
arg 'filter', :optional
command [:config] do |c|
  c.action do |global,opts,args|
    help_now! "Too many arguments" if args.count > 1
    args.delete('all')
    if Aws::ENI.configure(args.first) != 0
      puts 'synchronized interface config'
    else
      puts 'network interface config already in sync'
    end
  end
end

desc 'Remove custom configuration from network interfaces'
long_desc %{
  Remove custom configuration for a set of interfaces removing any custom ips,
  routes, and rules previously added (the 'eth0' primary IP is always left
  untouched for safety).

  Use the optional filter argument to limit this action to interfaces with a
  matching name, interface ID, subnet ID, or MAC address (default 'all').
}
arg 'filter', :optional
command [:deconfig] do |c|
  c.action do |global,opts,args|
    help_now! "Too many arguments" if args.count > 1
    args.delete('all')
    Aws::ENI.deconfigure(args.first)
  end
end

desc 'Enable network interface'
long_desc %{
  Enable one or more network interfaces (similar to 'ifup').

  Specify one name, interface ID, subnet ID, or MAC address to enable any
  matching interfaces, or specify 'all' to enable all interfaces.
}
arg 'filter'
command [:enable,:up] do |c|
  c.action do |global,opts,args|
    help_now! "Incorrect number of arguments" unless args.count.between?(0,1)
    args.delete('all')
    Aws::ENI::IFconfig.filter(args.first).each(&:enable)
    puts "interfaces enabled"
  end
end

desc 'Disable network interface'
long_desc %{
  Disable one or more network interfaces (similar to 'ifdown').

  Specify one name, interface ID, subnet ID, or MAC address to disable any
  matching interfaces, or specify 'all' to disable all interfaces.

  eth0 cannot be disabled.
}
arg 'filter'
command [:disable,:down] do |c|
  c.action do |global,opts,args|
    help_now! "Incorrect number of arguments" unless args.count.between?(0,1)
    args.delete('all')
    Aws::ENI::IFconfig.filter(args.first).each do |dev|
      if dev.name == 'eth0'
        warn 'skipping eth0'
      else
        dev.disable
        puts "interface #{dev.name} disabled"
      end
    end
  end
end

desc 'Create new network interface'
long_desc %{
  Create a new Elastic Network Interface with a given set of parameters.

  Optional arguments include subnet ID, security group IDs, and a primary ip
  address.

  If no subnet ID is provided (e.g. subnet-1a2b3c4d) the subnet for eth0 will
  be used. If no security group is provided (e.g. sg-1a2b3c4d) the VPC default
  security group will be used. If a private IP is provided, it must fall within
  the subnet's CIDR block. Arguments can be provided in any order.
}
arg 'subnet', :optional
arg 'security-groups', :optional
arg 'ip-address', :optional
command [:create] do |c|
  c.action do |global,opts,args|
    args.delete('new')
    params = parse_args args, :subnet_id, :security_groups, :primary_ip
    interface = Aws::ENI.create_interface(params)
    puts "interface #{interface[:interface_id]} created on #{interface[:subnet_id]}"
  end
end

desc 'Attach network interface'
long_desc %{
  Attach an Elastic Network Interface to our instance.

  If interface ID provided (e.g. eni-1a2b3c4d), that interface will be attached,
  otherwise a new interface will be created with the provided parameters which
  may include a subnet ID, security group IDs, and a primary IP address.

  If no subnet ID is provided (e.g. subnet-1a2b3c4d) the subnet for eth0 will
  be used. If no security group is provided (e.g. sg-1a2b3c4d) the VPC default
  security group will be used. If a private IP is provided, it must fall within
  the subnet's CIDR block. Arguments can be provided in any order.
}
arg 'interface-id', :optional
arg 'subnet-id', :optional
arg 'security-groups', :optional
arg 'ip-address', :optional
command [:attach] do |c|
  c.desc 'Do not configure or enable the device after attachment (implies block)'
  c.switch [:n,:noconfig], negatable: false

  c.desc 'Do not return until attachment is complete'
  c.switch [:b,:block], negatable: false

  c.action do |global,opts,args|
    config = !opts[:noconfig]
    if args.first =~ /^eni-/
      help_now! 'Too many arguments' if args.count > 1
      id = args.first
    else
      args.delete('new')
      params = parse_args args, :subnet_id, :security_groups, :primary_ip
      Aws::ENI.assert_ifconfig_access if config
      interface = Aws::ENI.create_interface(params)
      puts "interface #{interface[:interface_id]} created on #{interface[:subnet_id]}"
      id = interface[:interface_id]
    end
    device = Aws::ENI.attach_interface(id, enable: config, configure: config, block: opts[:block])
    puts "interface #{device[:interface_id]} attached to #{device[:device_name]}"
    puts "device #{device[:device_name]} enabled and configured" if config
  end
end

desc 'Detach network interface'
long_desc %{
  Detach an Elastic Network Interface from our instance.

  You must provide the interface ID (e.g. eni-1a2b3c4d) or the device name
  (e.g. eth1) or both.

  If no flag is present, the default action is to destroy the network interface
  after detachment only if it was originally created by aws-eni.
}
arg 'interface-id OR device-name'
command [:detach] do |c|
  c.desc 'Delete (or preserve) the unused ENI resource after dataching (implies block)'
  c.switch [:d,:delete], default_value: :not_provided # GLI behavior workaround

  c.desc 'Do not return until detachment is complete'
  c.switch [:b,:block], negatable: false

  c.action do |global,opts,args|
    help_now! "Missing argument" if args.empty?
    params = parse_args args, :interface_id, :device_name
    params[:block] = opts[:block]
    params[:delete] = opts[:delete] unless opts[:delete] == :not_provided
    id = params[:device_name] || params[:interface_id]

    device = Aws::ENI.detach_interface(id, params)
    if device[:deleted]
      puts "interface #{device[:interface_id]} detached from #{device[:device_name]} and deleted"
    else
      puts "interface #{device[:interface_id]} detached from #{device[:device_name]}"
    end
  end
end

desc 'Clean unattached network interfaces'
long_desc %{
  Delete unused Elastic Network Interfaces based on provided criteria.

  You may provide a specific interface ID (e.g. eni-1a2b3c4d), a subnet ID
  (e.g. subnet-1a2b3c4d), or an availability zone from this region (e.g.
  us-east-1a) to act as search criteria.

  By default, this will only delete ENIs which were originally created with this
  script.
}
arg 'filter', :optional
command [:clean] do |c|
  c.desc 'Force deletion of all unattached interfaces which meet our criteria'
  c.switch [:f,:force], negatable: false

  c.action do |global,opts,args|
    help_now! "Too many arguments" if args.count > 1
    deleted = Aws::ENI.clean_interfaces(args.first, safe_mode: !opts[:force])
    puts "#{deleted[:count]} interfaces deleted"
  end
end

desc 'Assign a new secondary private IP address'
long_desc %{
  Assign an additional private IP address to a given interface.

  You may optionally specify a private IP in the interface's subnet CIDR range
  to assign, otherwise one will be generated automatically.
}
arg 'ip-address', :optional
arg 'interface-id OR device-name'
command [:assign] do |c|
  c.desc 'Do not configure the interface after assignment'
  c.switch [:n,:noconfig], negatable: false

  c.desc 'Do not return until connection is verified'
  c.switch [:b,:block], negatable: false

  c.action do |global,opts,args|
    params = parse_args args, :interface_id, :device_name, :private_ip
    device = params[:device_name] || params[:interface_id]
    help_now! "Missing argument" if device.nil?

    params.merge! configure: !opts[:noconfig], block: opts[:block]
    Aws::ENI.assert_ifconfig_access if params[:configure]

    assignment = Aws::ENI.assign_secondary_ip(device, params)
    puts "IP #{assignment[:private_ip]} assigned to #{assignment[:device_name]} (#{assignment[:interface_id]})"
  end
end

desc 'Unassign a secondary private IP address'
long_desc %{
  Remove a private IP address from a given interface.  Any associated public ip
  address will be dissociated first and optionally released.

  If no interface is specified, it will be inferred by the IP address.
}
arg 'ip-address'
arg 'interface-id', :optional
arg 'device-name', :optional
command [:unassign] do |c|
  c.desc 'Release any associated public IP address'
  c.switch [:r,:release], negatable: false

  c.action do |global,opts,args|
    params = parse_args args, :interface_id, :device_name, :private_ip
    help_now! "Missing argument" unless params[:private_ip]
    params[:release] = opts[:release]

    unassign = Aws::ENI.unassign_secondary_ip(params[:private_ip], params)
    if unassign[:released]
      puts "EIP #{unassign[:public_ip]} (#{unassign[:allocation_id]}) dissociated from #{unassign[:private_ip]} and released"
    elsif unassign[:public_ip]
      puts "EIP #{unassign[:public_ip]} (#{unassign[:allocation_id]}) dissociated from #{unassign[:private_ip]}"
    end
    puts "IP #{unassign[:private_ip]} removed from #{unassign[:device_name]} (#{unassign[:interface_id]})"
  end
end

desc 'Associate a public IP address with a private IP address'
long_desc %{
  Associate a private IP address with a new or existing public IP address.

  If no public IP or allocation ID is provided, a new Elastic IP Address will be
  allocated and used.

  If no interface ID or device name provided, it will be inferred from the ip
  address.
}
arg 'private-ip'
arg 'public-ip', :optional
arg 'allocation-id', :optional
arg 'interface-id', :optional
arg 'device-name', :optional
command [:associate] do |c|
  c.desc 'Do not return until connection is verified'
  c.switch [:b,:block], negatable: false

  c.action do |global,opts,args|
    help_now! "Missing argument" if args.empty?
    args.delete('new')
    params = parse_args args, :private_ip, :public_ip, :allocation_id, :interface_id, :device_name
    params[:block] = opts[:block]
    assoc = Aws::ENI.associate_elastic_ip(params[:private_ip], params)
    puts "EIP #{assoc[:public_ip]} (#{assoc[:allocation_id]}) associated with #{assoc[:private_ip]} on #{assoc[:device_name]} (#{assoc[:interface_id]})"
  end
end

desc 'Dissociate a public IP address from a private IP address'
long_desc %{
  Remove an association between a given public IP address or private IP address
  and their counterpart.  The public IP address is then optionally released.
}
arg 'private-ip OR public-ip OR allocation-id'
arg 'interface-id', :optional
arg 'device-name', :optional
command [:dissociate] do |c|
  c.desc 'Release the associated public IP address'
  c.switch [:r,:release], negatable: false

  c.action do |global,opts,args|
    params = parse_args args, :private_ip, :public_ip, :allocation_id, :association_id, :interface_id, :device_name
    params[:release] = opts[:release]
    address = params[:private_ip] || params[:public_ip] || params[:association_id] || params[:allocation_id]
    help_now! "Missing argument" unless address
    dissoc = Aws::ENI.dissociate_elastic_ip(address, params)
    if dissoc[:released]
      puts "EIP #{dissoc[:public_ip]} (#{dissoc[:allocation_id]}) dissociated from #{dissoc[:private_ip]} on #{dissoc[:device_name]} (#{dissoc[:interface_id]}) and released"
    else
      puts "EIP #{dissoc[:public_ip]} (#{dissoc[:allocation_id]}) dissociated from #{dissoc[:private_ip]} on #{dissoc[:device_name]} (#{dissoc[:interface_id]})"
    end
  end
end

desc 'Allocate a new Elastic IP address'
long_desc %{
  Allocate a new Elastic IP address for use
}
command [:allocate] do |c|
  c.action do |global,opts,args|
    args.delete('new')
    help_now! "Invalid argument: #{args.first}" unless args.empty?
    alloc = Aws::ENI.allocate_elastic_ip
    puts "EIP #{alloc[:public_ip]} allocated as #{alloc[:allocation_id]}"
  end
end

desc 'Release unassigned Elastic IP addresses'
long_desc %{
  Release one unassigned Elastic IP addresses identified by its public IP or its
  allocation ID
}
arg 'ip-address OR allocation-id'
command [:release] do |c|
  c.action do |global,opts,args|
    help_now! "Missing argument" if args.empty?
    help_now! "Too many arguments" if args.count > 1
    params = parse_args args, :public_ip, :allocation_id
    eip = params[:public_ip] || params[:allocation_id]
    release = Aws::ENI.release_elastic_ip(eip)
    puts "EIP #{release[:public_ip]} (#{release[:allocation_id]}) released"
  end
end

desc 'Test access to AWS EC2 and our machine\'s network config'
long_desc %{
  Check for sufficient privileges to alter the local machine's network interface
  configuration and verify that the AWS access credentials include permissions
  necessary to perform all network related functions.
}
command [:test] do |c|
  c.action do |global,opts,args|
    help_now! "Too many arguments" if args.count > 1

    print 'IFconfig permissions test... '
    if Aws::ENI.can_modify_ifconfig?
      puts 'success!'
    else
      puts 'failed'
      puts "- unable to modify network configuration with /sbin/ip (try sudo)"
    end

    print 'AWS EC2 permissions test... '
    if Aws::ENI.can_access_ec2?
      puts 'success!'
    else
      puts 'failed'
      puts "- insufficient EC2 access. Ensure you have granted access to the"
      puts "  appropriate EC2 methods in your IAM policy (see documentation)"
    end
  end
end

# error handling

on_error do |exception|
  if Aws::ENI::PermissionError === exception
    warn 'error: This action requires super-user privileges (try sudo)'
    false
  else
    true
  end
end

ARGV << 'ls' if ARGV.empty?
exit run(ARGV)
